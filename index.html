<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PufferPanel Control • Dashboard</title>
  <meta name="description" content="GUI for controlling pufferpanel Docker container (ports, restart, status)" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Tailwind custom config
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            brand: {
              50: '#f6fbff',
              100: '#ecf7ff',
              200: '#cfe9ff',
              500: '#2b7cff'
            }
          }
        }
      }
    }
  </script>
  <style>
    /* small helpers */
    .glass { backdrop-filter: blur(6px) saturate(120%); background: rgba(255,255,255,0.06); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Noto Sans JP', monospace; }
  </style>
</head>
<body class="bg-gradient-to-br from-slate-900 via-indigo-900 to-rose-900 min-h-screen text-slate-100">
  <div class="max-w-6xl mx-auto p-6">
    <header class="flex items-center justify-between gap-4 mb-6">
      <div class="flex items-center gap-4">
        <div class="w-14 h-14 rounded-2xl bg-white/10 flex items-center justify-center ring-1 ring-white/10">
          <svg width="36" height="36" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 12h6" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M21 12h-6" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <circle cx="12" cy="12" r="8" stroke="#fff" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
        <div>
          <h1 class="text-2xl font-semibold">PufferPanel Control</h1>
          <p class="text-sm text-white/70">Ports, restart and quick health checks — lightweight UI for GitHub Pages</p>
        </div>
      </div>

      <div class="flex items-center gap-3">
        <div id="apiStatus" class="px-3 py-1 rounded-full bg-white/6 border border-white/6 font-medium text-sm flex items-center gap-2">
          <span class="w-2 h-2 rounded-full bg-yellow-400" id="apiStatusDot"></span>
          <span id="apiStatusText">Waiting (no server)</span>
        </div>
        <div id="daemonStatus" class="px-3 py-1 rounded-full bg-white/6 border border-white/6 font-medium text-sm flex items-center gap-2">
          <span class="w-2 h-2 rounded-full bg-gray-400" id="daemonStatusDot"></span>
          <span id="daemonStatusText">Daemon: waiting</span>
        </div>
      </div>
    </header>

    <main class="grid grid-cols-1 md:grid-cols-3 gap-6">
      <!-- LEFT: Settings -->
      <section class="glass rounded-2xl p-4 md:col-span-1">
        <h2 class="text-lg font-semibold mb-2">Connection</h2>
        <p class="text-sm text-white/70 mb-4">Enter your API server and API key. Keys are masked. You can optionally save them locally.</p>

        <label class="block text-sm text-white/80 mb-1">Server URL</label>
        <input id="serverInput" class="w-full rounded-md p-2 mb-3 bg-white/5 placeholder:text-white/50" placeholder="http://192.168.1.5:3000 or 192.168.1.5:3000" />

        <label class="block text-sm text-white/80 mb-1">API Key</label>
        <div class="flex gap-2 mb-3">
          <input id="apiKeyInput" type="password" class="flex-1 rounded-md p-2 bg-white/5" placeholder="hidden" />
          <button id="toggleReveal" class="px-3 py-2 rounded-md bg-white/6">Show</button>
        </div>

        <label class="inline-flex items-center gap-2 text-sm mb-3">
          <input id="saveKey" type="checkbox" class="rounded" checked />
          <span class="text-white/80">Save API key locally (lightly obfuscated)</span>
        </label>

        <label class="block text-sm text-white/80 mb-1">Default container</label>
        <input id="containerInput" class="w-full rounded-md p-2 mb-3 bg-white/5" placeholder="pufferpanel" />

        <div class="flex gap-2">
          <button id="btnTest" class="flex-1 px-3 py-2 rounded-md bg-brand-500 hover:brightness-105">Test & Connect</button>
          <button id="btnClear" class="px-3 py-2 rounded-md bg-white/6">Clear</button>
        </div>

        <p class="text-xs text-yellow-200 mt-3">Note: enable CORS on your API (ALLOW_CORS=true) or configure your reverse proxy. Do not store keys on public/shared devices.</p>
      </section>

      <!-- CENTER: Controls -->
      <section class="glass rounded-2xl p-4 md:col-span-2">
        <div class="flex items-center justify-between mb-4">
          <h2 class="text-lg font-semibold">Controls</h2>
          <div class="text-sm text-white/70">Connected: <span id="connectedText">No</span></div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4 mb-4">
          <div class="p-3 bg-white/5 rounded-lg">
            <div class="text-sm mb-2 font-medium">Restart Server</div>
            <div class="text-xs text-white/70 mb-3">Restart the configured container</div>
            <div class="flex gap-2">
              <button id="btnRestart" class="flex-1 py-2 rounded-md bg-rose-500">Restart</button>
            </div>
          </div>

          <div class="p-3 bg-white/5 rounded-lg">
            <div class="text-sm mb-2 font-medium">Ports: Refresh</div>
            <div class="text-xs text-white/70 mb-3">Fetch published ports from container</div>
            <div class="flex gap-2">
              <button id="btnRefreshPorts" class="flex-1 py-2 rounded-md bg-indigo-600">Refresh</button>
            </div>
          </div>

          <div class="p-3 bg-white/5 rounded-lg">
            <div class="text-sm mb-2 font-medium">Daemon Check</div>
            <div class="text-xs text-white/70 mb-3">Hit http://[IP]:8080/daemon (default)</div>
            <div class="flex gap-2">
              <button id="btnDaemonCheck" class="flex-1 py-2 rounded-md bg-emerald-500">Check</button>
            </div>
          </div>
        </div>

        <div class="mb-6">
          <h3 class="text-md font-semibold mb-2">Published Ports</h3>
          <div id="portsList" class="space-y-2 text-sm text-white/80">
            <!-- populated dynamically -->
            <div class="text-xs text-white/60">No data</div>
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
          <div>
            <label class="text-sm mb-1 block">Add mapping (host:container)</label>
            <input id="mapInput" placeholder="8080:80" class="w-full p-2 rounded bg-white/5" />
          </div>
          <div>
            <label class="text-sm mb-1 block">Protocol</label>
            <select id="protoSelect" class="w-full p-2 rounded bg-white/5">
              <option value="tcp">tcp</option>
              <option value="udp">udp</option>
            </select>
          </div>
          <div>
            <button id="btnAddPort" class="w-full py-2 rounded-md bg-indigo-500">Add Port</button>
            <button id="btnRemovePort" class="w-full mt-2 py-2 rounded-md bg-white/6">Remove Port</button>
          </div>
        </div>

        <div id="logArea" class="mt-6 p-3 bg-white/4 rounded-lg mono text-xs max-h-48 overflow-auto"></div>
      </section>
    </main>

    <footer class="mt-8 text-center text-white/60 text-sm">
      Built for private use. Keep your API key secret. UI by you — deploy on GitHub Pages.
    </footer>
  </div>

<script>
/* ---------- improved client-side script ---------- */
/* 主な改良点
   - サーバー入力が scheme を持たない場合に自動補完 (http:// を追加)
   - デーモンチェックはサーバーのホスト名を使い、ポートが明示されていればそのポートを優先、なければ :8080 を使う
   - fetch のエラーハンドリング強化（非 JSON レスポンスでも安全にログ）
   - 接続状態に応じて操作ボタンを無効化/有効化
   - localStorage の保存ロジック改善
*/

const $ = id => document.getElementById(id);
const baseKey = 'puffer_ui_saved_v2';
let connected = false; // 真に接続確認できたとき true

function log(...args) {
  const out = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');
  const el = $('logArea');
  const p = document.createElement('div');
  p.textContent = new Date().toLocaleTimeString() + ' — ' + out;
  el.prepend(p);
}

function setStatus(apiOk, text) {
  const dot = $('apiStatusDot');
  const t = $('apiStatusText');
  dot.style.background = apiOk ? '#34D399' : '#F59E0B';
  t.textContent = text;
}

function setDaemonStatus(ok, text) {
  const dot = $('daemonStatusDot');
  const t = $('daemonStatusText');
  dot.style.background = ok ? '#34D399' : '#F87171';
  t.textContent = text;
}

function enableControls(enable) {
  // 接続済みなら主要ボタンを有効化
  ['btnRestart','btnRefreshPorts','btnDaemonCheck','btnAddPort','btnRemovePort'].forEach(id => {
    const el = $(id);
    if (!el) return;
    el.disabled = !enable;
    el.classList.toggle('opacity-50', !enable);
    el.classList.toggle('cursor-not-allowed', !enable);
  });
}

function storeSaved(server, key, container, save) {
  if (!save) { localStorage.removeItem(baseKey); return; }
  try {
    const payload = { server, key: btoa(key || ''), container };
    localStorage.setItem(baseKey, JSON.stringify(payload));
  } catch(e) {
    console.warn('store failed', e);
  }
}

function loadSaved() {
  try {
    const raw = localStorage.getItem(baseKey);
    if (!raw) return null;
    const p = JSON.parse(raw);
    return { server: p.server, key: p.key ? atob(p.key) : '', container: p.container };
  } catch(e) { return null; }
}

function clearSavedInputs() {
  $('serverInput').value = '';
  $('apiKeyInput').value = '';
  $('containerInput').value = '';
  $('saveKey').checked = true;
  localStorage.removeItem(baseKey);
  connected = false;
  updateConnectionState();
  setStatus(false, 'Waiting (no server)');
  setDaemonStatus(false, 'Daemon: waiting');
  enableControls(false);
}

function getConfigFromUI() {
  const server = $('serverInput').value.trim();
  const apiKey = $('apiKeyInput').value;
  const container = $('containerInput').value.trim() || 'pufferpanel';
  return { server, apiKey, container };
}

function headersFromKey(key) {
  const h = { 'Content-Type': 'application/json' };
  if (key) {
    h['x-api-key'] = key;
    h['Authorization'] = 'Bearer ' + key;
  }
  return h;
}

function normalizeServerInput(raw) {
  // scheme がなければ http:// を補完。URL 解析に失敗したら null を返す
  if (!raw) return null;
  let txt = raw.trim();
  if (!/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(txt)) {
    txt = 'http://' + txt;
  }
  try {
    const u = new URL(txt);
    // 切り詰め（末尾のスラッシュを除去）
    u.pathname = u.pathname.replace(/\/+$/, '');
    return u;
  } catch(e) {
    return null;
  }
}

async function safeReadResponse(res) {
  // レスポンスを JSON かテキストで安全に読み取る
  const ct = res.headers.get('content-type') || '';
  try {
    if (ct.includes('application/json')) return await res.json();
    return await res.text();
  } catch(e) {
    return await res.text().catch(()=>null);
  }
}

async function testApi() {
  const { server, apiKey } = getConfigFromUI();
  if (!server || !apiKey) { setStatus(false, 'Waiting (enter server & key)'); return false; }
  const urlObj = normalizeServerInput(server);
  if (!urlObj) { setStatus(false, 'Invalid server URL'); log('Invalid server URL', server); return false; }

  const healthUrl = `${urlObj.origin}/health`;
  try {
    const res = await fetch(healthUrl, { headers: headersFromKey(apiKey), mode: 'cors' });
    const body = await safeReadResponse(res);
    if (!res.ok) {
      setStatus(false, 'API: Error');
      log('Health error', res.status, body);
      connected = false;
      updateConnectionState();
      enableControls(false);
      return false;
    }
    setStatus(true, 'API: OK');
    log('Health ->', body);
    connected = true;
    updateConnectionState();
    enableControls(true);
    return true;
  } catch (e) {
    setStatus(false, 'API: Error');
    log('Health error', e.message || e);
    connected = false;
    updateConnectionState();
    enableControls(false);
    return false;
  }
}

async function checkDaemon() {
  const { server } = getConfigFromUI();
  if (!server) { setDaemonStatus(false, 'Daemon: waiting (no IP)'); return; }
  const urlObj = normalizeServerInput(server);
  if (!urlObj) { setDaemonStatus(false, 'Daemon: invalid server'); log('Daemon: invalid server', server); return; }

  // サーバーで port が明示されていればそれを使い、なければデフォルト 8080 を使う
  const port = urlObj.port || '8080';
  const checkUrl = `${urlObj.protocol}//${urlObj.hostname}:${port}/daemon`;
  try {
    const res = await fetch(checkUrl, { mode: 'cors' });
    const txt = await safeReadResponse(res);
    if (!res.ok) throw new Error('HTTP ' + res.status + ' — ' + (typeof txt === 'string' ? txt.slice(0,200) : JSON.stringify(txt)));
    setDaemonStatus(true, `Daemon: responded (:${port})`);
    log('Daemon OK', checkUrl, typeof txt === 'string' ? txt.slice(0,200) : txt);
  } catch (e) {
    setDaemonStatus(false, 'Daemon: error');
    log('Daemon check error', e.message || e);
  }
}

async function restartContainer() {
  const { server, apiKey, container } = getConfigFromUI();
  if (!server || !apiKey) return alert('Enter server and API key');
  const urlObj = normalizeServerInput(server);
  if (!urlObj) return alert('Invalid server URL');
  const endpoint = `${urlObj.origin}/restart`;
  try {
    const res = await fetch(endpoint, {
      method: 'POST', headers: headersFromKey(apiKey), body: JSON.stringify({ name: container })
    });
    const j = await safeReadResponse(res);
    if (!res.ok) { log('Restart failed', res.status, j); alert('Restart failed'); return; }
    log('Restart', j);
    alert('Restart requested');
  } catch (e) { log('Restart error', e); alert('Error: ' + (e.message||e)); }
}

async function refreshPorts() {
  const { server, apiKey, container } = getConfigFromUI();
  if (!server || !apiKey) return alert('Enter server and API key');
  const urlObj = normalizeServerInput(server);
  if (!urlObj) return alert('Invalid server URL');
  const endpoint = `${urlObj.origin}/ports?name=${encodeURIComponent(container)}`;
  try {
    const res = await fetch(endpoint, { headers: headersFromKey(apiKey), mode: 'cors' });
    const j = await safeReadResponse(res);
    if (!res.ok) { log('Ports fetch failed', res.status, j); alert('Failed to get ports'); return; }
    // j がオブジェクトで ports を持つパターンと、直接配列のパターンを想定
    const ports = Array.isArray(j) ? j : (j && j.ports) ? j.ports : [];
    renderPorts(ports);
    log('Ports', ports);
  } catch (e) { log('Ports error', e); alert('Error: ' + (e.message||e)); }
}

function renderPorts(list) {
  const div = $('portsList');
  div.innerHTML = '';
  if (!list || !list.length) return div.innerHTML = '<div class="text-xs text-white/60">No published ports</div>';
  for (const p of list) {
    const hostIp = p.hostIp ?? p.host ?? p.HostIp ?? '0.0.0.0';
    const hostPort = p.hostPort ?? p.hostPort ?? p.HostPort ?? p.PublishedPort ?? ('?');
    const containerPort = p.containerPort ?? p.container ?? p.ContainerPort ?? p.PrivatePort ?? '?';
    const protocol = p.protocol ?? p.Protocol ?? (p.mode?.toLowerCase?.() === 'udp' ? 'udp' : 'tcp');
    const el = document.createElement('div');
    el.className = 'flex items-center justify-between bg-white/2 p-2 rounded';
    el.innerHTML = `<div class="text-sm">${hostIp}:${hostPort} → <span class="text-white/90">:${containerPort}/${protocol}</span></div>`;
    div.appendChild(el);
  }
}

async function addPort() {
  const { server, apiKey, container } = getConfigFromUI();
  const mapping = $('mapInput').value.trim();
  const proto = $('protoSelect').value || 'tcp';
  if (!mapping) return alert('Enter mapping like 8080:80');
  const urlObj = normalizeServerInput(server);
  if (!urlObj) return alert('Invalid server URL');
  try {
    const payload = { name: container, mappings: [ `${mapping}${proto==='udp'?'/udp':''}` ] };
    const res = await fetch(`${urlObj.origin}/ports/add`, { method: 'POST', headers: headersFromKey(apiKey), body: JSON.stringify(payload), mode: 'cors' });
    const j = await safeReadResponse(res);
    if (!res.ok) { log('Add failed', res.status, j); alert('Add port failed'); return; }
    log('Add result', j);
    await refreshPorts();
  } catch (e) { log('Add error', e); alert('Error: '+(e.message||e)); }
}

async function removePort() {
  const { server, apiKey, container } = getConfigFromUI();
  const mapping = $('mapInput').value.trim();
  const proto = $('protoSelect').value || 'tcp';
  if (!mapping) return alert('Enter mapping like 8080:80');
  const urlObj = normalizeServerInput(server);
  if (!urlObj) return alert('Invalid server URL');
  try {
    const payload = { name: container, mappings: [ `${mapping}${proto==='udp'?'/udp':''}` ] };
    const res = await fetch(`${urlObj.origin}/ports/remove`, { method: 'POST', headers: headersFromKey(apiKey), body: JSON.stringify(payload), mode: 'cors' });
    const j = await safeReadResponse(res);
    if (!res.ok) { log('Remove failed', res.status, j); alert('Remove port failed'); return; }
    log('Remove result', j);
    await refreshPorts();
  } catch (e) { log('Remove error', e); alert('Error: '+(e.message||e)); }
}

// UI wiring
$('toggleReveal').addEventListener('click', () => {
  const el = $('apiKeyInput');
  if (el.type === 'password') { el.type = 'text'; $('toggleReveal').textContent = 'Hide'; } else { el.type = 'password'; $('toggleReveal').textContent = 'Show'; }
});

$('btnTest').addEventListener('click', async () => {
  const { server, apiKey, container } = getConfigFromUI();
  if (!server || !apiKey) return alert('Enter server and API key');
  const ok = await testApi();
  if (ok) {
    storeSaved(server, apiKey, container, $('saveKey').checked);
    await refreshPorts();
    await checkDaemon();
  }
});
$('btnClear').addEventListener('click', () => clearSavedInputs());
$('btnRestart').addEventListener('click', () => { if (confirm('Restart container?')) restartContainer(); });
$('btnRefreshPorts').addEventListener('click', refreshPorts);
$('btnDaemonCheck').addEventListener('click', checkDaemon);
$('btnAddPort').addEventListener('click', addPort);
$('btnRemovePort').addEventListener('click', removePort);

// load saved
window.addEventListener('load', () => {
  const saved = loadSaved();
  if (saved) {
    $('serverInput').value = saved.server || '';
    $('apiKeyInput').value = saved.key || '';
    $('containerInput').value = saved.container || 'pufferpanel';
  }
  // 初期状態では未接続扱い
  setStatus(false, $('serverInput').value ? 'Not tested' : 'Waiting (no server)');
  setDaemonStatus(false, 'Daemon: waiting');
  connected = false;
  updateConnectionState();
  enableControls(false);
});

function updateConnectionState() {
  $('connectedText').textContent = connected ? 'Yes' : 'No';
}

['serverInput','apiKeyInput','containerInput'].forEach(id => {
  $(id).addEventListener('input', updateConnectionState);
});

</script>
</body>
</html>
